/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub type wchar_t = ::std::os::raw::c_ushort;
pub type DWORD = ::std::os::raw::c_ulong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type CHAR = ::std::os::raw::c_char;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = wchar_t;
pub type LPWSTR = *mut WCHAR;
pub type LPSTR = *mut CHAR;
pub type LONGLONG = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LARGE_INTEGER {
    pub __bindgen_anon_1: __BindgenUnionField<_LARGE_INTEGER__bindgen_ty_1>,
    pub u: __BindgenUnionField<_LARGE_INTEGER__bindgen_ty_2>,
    pub QuadPart: __BindgenUnionField<LONGLONG>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( _LARGE_INTEGER__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( _LARGE_INTEGER__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LARGE_INTEGER__bindgen_ty_1 ) ) .
                LowPart as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _LARGE_INTEGER__bindgen_ty_1 ) , "::" , stringify ! ( LowPart
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LARGE_INTEGER__bindgen_ty_1 ) ) .
                HighPart as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _LARGE_INTEGER__bindgen_ty_1 ) , "::" , stringify ! ( HighPart
                ) ));
}
impl Clone for _LARGE_INTEGER__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( _LARGE_INTEGER__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( _LARGE_INTEGER__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LARGE_INTEGER__bindgen_ty_2 ) ) .
                LowPart as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _LARGE_INTEGER__bindgen_ty_2 ) , "::" , stringify ! ( LowPart
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LARGE_INTEGER__bindgen_ty_2 ) ) .
                HighPart as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                _LARGE_INTEGER__bindgen_ty_2 ) , "::" , stringify ! ( HighPart
                ) ));
}
impl Clone for _LARGE_INTEGER__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    assert_eq!(::std::mem::size_of::<_LARGE_INTEGER>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _LARGE_INTEGER ) ));
    assert_eq! (::std::mem::align_of::<_LARGE_INTEGER>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _LARGE_INTEGER ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LARGE_INTEGER ) ) . u as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LARGE_INTEGER ) , "::"
                , stringify ! ( u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _LARGE_INTEGER ) ) . QuadPart as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _LARGE_INTEGER ) , "::"
                , stringify ! ( QuadPart ) ));
}
impl Clone for _LARGE_INTEGER {
    fn clone(&self) -> Self { *self }
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type SECURITY_STATUS = LONG;
pub type SEC_WCHAR = WCHAR;
pub type SEC_CHAR = CHAR;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SecHandle {
    pub dwLower: ULONG_PTR,
    pub dwUpper: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__SecHandle() {
    assert_eq!(::std::mem::size_of::<_SecHandle>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _SecHandle ) ));
    assert_eq! (::std::mem::align_of::<_SecHandle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _SecHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecHandle ) ) . dwLower as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecHandle ) , "::" ,
                stringify ! ( dwLower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecHandle ) ) . dwUpper as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecHandle ) , "::" ,
                stringify ! ( dwUpper ) ));
}
impl Clone for _SecHandle {
    fn clone(&self) -> Self { *self }
}
pub type PSecHandle = *mut _SecHandle;
pub type PCredHandle = PSecHandle;
pub type PCtxtHandle = PSecHandle;
pub type SECURITY_INTEGER = LARGE_INTEGER;
pub type PTimeStamp = *mut SECURITY_INTEGER;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SecBuffer {
    pub cbBuffer: ::std::os::raw::c_ulong,
    pub BufferType: ::std::os::raw::c_ulong,
    pub pvBuffer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__SecBuffer() {
    assert_eq!(::std::mem::size_of::<_SecBuffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _SecBuffer ) ));
    assert_eq! (::std::mem::align_of::<_SecBuffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _SecBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecBuffer ) ) . cbBuffer as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecBuffer ) , "::" ,
                stringify ! ( cbBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecBuffer ) ) . BufferType as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecBuffer ) , "::" ,
                stringify ! ( BufferType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecBuffer ) ) . pvBuffer as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecBuffer ) , "::" ,
                stringify ! ( pvBuffer ) ));
}
impl Clone for _SecBuffer {
    fn clone(&self) -> Self { *self }
}
pub type PSecBuffer = *mut _SecBuffer;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _SecBufferDesc {
    pub ulVersion: ::std::os::raw::c_ulong,
    pub cBuffers: ::std::os::raw::c_ulong,
    pub pBuffers: PSecBuffer,
}
#[test]
fn bindgen_test_layout__SecBufferDesc() {
    assert_eq!(::std::mem::size_of::<_SecBufferDesc>() , 16usize , concat ! (
               "Size of: " , stringify ! ( _SecBufferDesc ) ));
    assert_eq! (::std::mem::align_of::<_SecBufferDesc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _SecBufferDesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecBufferDesc ) ) . ulVersion as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecBufferDesc ) , "::"
                , stringify ! ( ulVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecBufferDesc ) ) . cBuffers as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecBufferDesc ) , "::"
                , stringify ! ( cBuffers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _SecBufferDesc ) ) . pBuffers as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _SecBufferDesc ) , "::"
                , stringify ! ( pBuffers ) ));
}
impl Clone for _SecBufferDesc {
    fn clone(&self) -> Self { *self }
}
pub type PSecBufferDesc = *mut _SecBufferDesc;
pub type SEC_GET_KEY_FN =
    ::std::option::Option<unsafe extern "C" fn(Arg:
                                                   *mut ::std::os::raw::c_void,
                                               Principal:
                                                   *mut ::std::os::raw::c_void,
                                               KeyVer:
                                                   ::std::os::raw::c_ulong,
                                               Key:
                                                   *mut *mut ::std::os::raw::c_void,
                                               Status: *mut SECURITY_STATUS)>;
#[link(name = "Secur32")]
extern "C" {
    pub fn AcquireCredentialsHandleW(pszPrincipal: LPWSTR, pszPackage: LPWSTR,
                                     fCredentialUse: ::std::os::raw::c_ulong,
                                     pvLogonId: *mut ::std::os::raw::c_void,
                                     pAuthData: *mut ::std::os::raw::c_void,
                                     pGetKeyFn: SEC_GET_KEY_FN,
                                     pvGetKeyArgument:
                                         *mut ::std::os::raw::c_void,
                                     phCredential: PCredHandle,
                                     ptsExpiry: PTimeStamp)
     -> SECURITY_STATUS;
}
#[link(name = "Secur32")]
extern "C" {
    pub fn AcquireCredentialsHandleA(pszPrincipal: LPSTR, pszPackage: LPSTR,
                                     fCredentialUse: ::std::os::raw::c_ulong,
                                     pvLogonId: *mut ::std::os::raw::c_void,
                                     pAuthData: *mut ::std::os::raw::c_void,
                                     pGetKeyFn: SEC_GET_KEY_FN,
                                     pvGetKeyArgument:
                                         *mut ::std::os::raw::c_void,
                                     phCredential: PCredHandle,
                                     ptsExpiry: PTimeStamp)
     -> SECURITY_STATUS;
}
extern "C" {
    pub fn InitializeSecurityContextW(phCredential: PCredHandle,
                                      phContext: PCtxtHandle,
                                      pszTargetName: *mut SEC_WCHAR,
                                      fContextReq: ::std::os::raw::c_ulong,
                                      Reserved1: ::std::os::raw::c_ulong,
                                      TargetDataRep: ::std::os::raw::c_ulong,
                                      pInput: PSecBufferDesc,
                                      Reserved2: ::std::os::raw::c_ulong,
                                      phNewContext: PCtxtHandle,
                                      pOutput: PSecBufferDesc,
                                      pfContextAttr:
                                          *mut ::std::os::raw::c_ulong,
                                      ptsExpiry: PTimeStamp)
     -> SECURITY_STATUS;
}
extern "C" {
    pub fn InitializeSecurityContextA(phCredential: PCredHandle,
                                      phContext: PCtxtHandle,
                                      pszTargetName: *mut SEC_CHAR,
                                      fContextReq: ::std::os::raw::c_ulong,
                                      Reserved1: ::std::os::raw::c_ulong,
                                      TargetDataRep: ::std::os::raw::c_ulong,
                                      pInput: PSecBufferDesc,
                                      Reserved2: ::std::os::raw::c_ulong,
                                      phNewContext: PCtxtHandle,
                                      pOutput: PSecBufferDesc,
                                      pfContextAttr:
                                          *mut ::std::os::raw::c_ulong,
                                      ptsExpiry: PTimeStamp)
     -> SECURITY_STATUS;
}
extern "C" {
    pub fn CompleteAuthToken(phContext: PCtxtHandle, pToken: PSecBufferDesc)
     -> SECURITY_STATUS;
}
extern "C" {
    pub fn SaslInitializeSecurityContextW(phCredential: PCredHandle,
                                          phContext: PCtxtHandle,
                                          pszTargetName: LPWSTR,
                                          fContextReq:
                                              ::std::os::raw::c_ulong,
                                          Reserved1: ::std::os::raw::c_ulong,
                                          TargetDataRep:
                                              ::std::os::raw::c_ulong,
                                          pInput: PSecBufferDesc,
                                          Reserved2: ::std::os::raw::c_ulong,
                                          phNewContext: PCtxtHandle,
                                          pOutput: PSecBufferDesc,
                                          pfContextAttr:
                                              *mut ::std::os::raw::c_ulong,
                                          ptsExpiry: PTimeStamp)
     -> SECURITY_STATUS;
}
extern "C" {
    pub fn SaslInitializeSecurityContextA(phCredential: PCredHandle,
                                          phContext: PCtxtHandle,
                                          pszTargetName: LPSTR,
                                          fContextReq:
                                              ::std::os::raw::c_ulong,
                                          Reserved1: ::std::os::raw::c_ulong,
                                          TargetDataRep:
                                              ::std::os::raw::c_ulong,
                                          pInput: PSecBufferDesc,
                                          Reserved2: ::std::os::raw::c_ulong,
                                          phNewContext: PCtxtHandle,
                                          pOutput: PSecBufferDesc,
                                          pfContextAttr:
                                              *mut ::std::os::raw::c_ulong,
                                          ptsExpiry: PTimeStamp)
     -> SECURITY_STATUS;
}
